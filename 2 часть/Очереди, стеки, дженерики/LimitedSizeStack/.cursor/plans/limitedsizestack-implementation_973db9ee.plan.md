---
name: limitedsizestack-implementation
overview: Реализация стека ограниченного размера с операциями Push/Pop за O(1) и корректной работой сборщика мусора.
todos:
  - id: impl-constructor-fields
    content: Реализовать поля и конструктор `LimitedSizeStack<T>` с проверкой `undoLimit` и инициализацией кольцевого буфера.
    status: pending
  - id: impl-push
    content: Реализовать метод `Push(T item)` с O(1) логикой и вытеснением самого глубокого элемента при переполнении.
    status: pending
  - id: impl-pop
    content: Реализовать метод `Pop()` с O(1) логикой, корректным выбрасыванием исключения при пустом стеке и очисткой ссылки в массиве.
    status: pending
  - id: impl-count
    content: Реализовать свойство `Count` как возврат `_count`.
    status: pending
isProject: false
---

### Цели

- **Реализовать `LimitedSizeStack<T>`**, который хранит не более `undoLimit` последних элементов.
- **Гарантировать O(1) для `Push` и `Pop`**, независимо от размера стека или лимита.
- **Обеспечить отсутствие висячих ссылок** на элементы, вытесненные из стека, чтобы тест с финализатором проходил.

### Основная идея реализации

- **Внутреннее представление**: использовать кольцевой буфер на массиве фиксированного размера `T[]`, а не `List<T>` и не `Stack<T>`, чтобы полностью контролировать сложность и управление ссылками.
- **Поля**:
- `private readonly int _limit;` — максимально допустимое число элементов.
- `private readonly T[] _items;` — массив ёмкостью `_limit` (либо пустой массив при лимите 0).
- `private int _start;` — индекс самого "глубокого" (старейшего) элемента в массиве.
- `private int _count;` — текущее количество элементов (0.._limit).
- **Инварианты**:
- При `undoLimit < 0` — выбрасывать `ArgumentOutOfRangeException` в конструкторе.
- При `_limit == 0` стек никогда ничего не хранит: `Push` ничего не делает, `Count` всегда 0, `Pop` кидает `InvalidOperationException` как у обычного стека при попытке извлечь из пустого.
- Логический стек: элементы от "дна" к вершине находятся по индексам `(_start + i) % _limit`, где `i = 0.._count-1`.

### Реализация методов

- **Конструктор `LimitedSizeStack(int undoLimit)`**
- Сохранить `_limit = undoLimit`.
- Если `undoLimit < 0` — бросить `ArgumentOutOfRangeException`.
- Если `undoLimit == 0` — `
_items = Array.Empty<T>();
_start = 0;
_count = 0;`
- Иначе — `
_items = new T[undoLimit];
_start = 0;
_count = 0;`

- **Свойство `Count`**
- Просто возвращать `_count` без дополнительной логики, операция за O(1).

- **Метод `Push(T item)`**
- Если `_limit == 0` — сразу выход (ничего не храним, тест `WorkCorrectlyWhenLimitZero` ожидает `Count == 0`).
- Если стек ещё не заполнен (`_count < _limit`):
- Вычислить индекс вершины для нового элемента: `int index = (_start + _count) % _limit;`.
- Записать элемент в `_items[index]`.
- Увеличить `_count`.
- Если стек заполнен (`_count == _limit`):
- Сдвинуть `_start` вперёд на 1 по модулю `_limit`: `_start = (_start + 1) % _limit;` — это логически "выбрасывает" самый глубокий элемент.
- Вычислить индекс вершины: `int index = (_start + _count - 1) % _limit;` (последний логический элемент).
- Перезаписать `_items[index] = item;` — старейший элемент уже недостижим, GC сможет его собрать.
- Не использовать `Last()` и другие O(N) операции; вся логика — через индексы.

- **Метод `T Pop()`**
- Если `_count == 0` — бросить `InvalidOperationException("Stack is empty")`, аналогично стандартному `Stack<T>` (тесты не вызывают Pop на пустом стеке, но корректное поведение важно).
- Вычислить индекс вершины: `int topIndex = (_start + _count - 1) % _limit;`.
- Сохранить возвращаемое значение: `var result = _items[topIndex];`.
- Обнулить слот для корректной работы GC: `_items[topIndex] = default!;` — так стек не хранит ссылок на извлечённый объект.
- Уменьшить `_count`.
- При `_count == 0` можно сбросить `_start = 0;` (для аккуратности, не обязательно для корректности, но это упрощает состояние).
- Вернуть `result`.

### Проверка против существующих тестов

- **Корректность LIFO-семантики**
- Тесты `PopAfterPush`, `PushAfterPop`, `PushAfterEmptyStack`, `PopPushAfterLimitReached` проверяют порядок элементов и поведение после вытеснения; предложенная кольцевая схема сохраняет LIFO-поведение.
- **Ограничение по размеру**
- Тесты `ForgetFirstElement_AfterPushBeyondLimit` и `ForgetFirstElement_AfterPushBeyondLimit_Twice` проверяют, что при переполнении забывается самый глубокий элемент, а количество элементов в стеке не превышает лимит — это обеспечивается сдвигом `_start` и ограничением `_count`.
- **Поведение при лимите 0**
- Тест `WorkCorrectlyWhenLimitZero` ожидает, что после любых `Push` `Count` остаётся 0 — это выполняется, потому что при `_limit == 0` `Push` ничего не делает.
- **GC и отсутствие лишних ссылок**
- Тест `StackDontKeepAllElements` создаёт 100 объектов при лимите 30 и ожидает финализацию 70 штук; фиксированный массив на `_limit` элементов с перезаписью ячеек при вытеснении и обнулением слота при `Pop` гарантирует отсутствие ссылок на старые элементы.
- **Производительность**
- Тесты в `LimitedSizeStack_PerformanceTest` требуют, чтобы `Push` и `Pop` были O(1) при большом лимите; работа только с индексами массива и простыми арифметическими операциями по модулю удовлетворяет этому требованию.

### Файлы для изменения

- **Только** `[...]/LimitedSizeStack/LimitedSizeStack.cs `— реализация класса `LimitedSizeStack<T>`.
- Другие файлы (`ListModel.cs` и UI-проект) в рамках этой задачи не трогаем.